#!/usr/bin/python
from __future__ import print_function

import logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s| %(name)s/%(process)d: %(message)s '
           '@%(funcName)s:%(lineno)d #%(levelname)s',
)
_LOG = logging.getLogger('apply-state-layer')

import subprocess
import os
import sys

import salt.config
import salt.client
import salt.output
import yaml


def _logger_setup(env_var='LOG_LEVEL', default_level=logging.INFO):
    '''
    Configure logger based on env var with default level.
    '''
    log_level = os.environ.get(env_var, default_level)
    log_level = logging.getLevelName(log_level)
    _LOG.setLevel(log_level)

_logger_setup()


# State layer paths
VK_ROOT = os.environ['VK_ROOT']
SALT_ROOT = os.path.join(VK_ROOT, 'salt')
LAYER_ROOT = os.path.join(SALT_ROOT, 'layers')
STATE_ROOT = os.path.join(SALT_ROOT, 'states')
PILLAR_ROOT = os.path.join(SALT_ROOT, 'pillar')
# Ensure sane environment
assert all([os.path.isdir(x) for x in (VK_ROOT, SALT_ROOT, STATE_ROOT, PILLAR_ROOT)])


def image_cleanup():
    '''
    Cleans up image; cleans apt cache and downloaded lists.
    '''
    _LOG.debug("Running image cleanup")
    subprocess.check_call(["image-cleanup"])


def touch(file_path):
    '''
    Convenience wrapper for 'touch'ing a file.
    '''
    with open(file_path, 'a'):
        os.utime(file_path, None)
    return True


class StateLayer(object):
    '''
    An individual Salt State Layer.
    The purpose of a state layer is to allow easy caching of Docker images when being built with Salt.
    '''

    def __init__(self, path, name=None):
        # No trailing slash
        if path.endswith('/'):
            path = path[:-1]

        if not name:
            name = os.path.basename(path)
        self.name = name

        self.given_path = path
        self.abs_given_path = os.path.abspath(path)
        self.path = os.path.realpath(self.abs_given_path)

        self.layer_path = os.path.join(LAYER_ROOT, self.name)

        self._validate()

    def __repr__(self):
        return '<%s:%s>' % (
            self.__class__.__name__,
            self.name,
        )

    def _validate(self):
        '''
        Validates the state layer to make sure it has the needed files.
        '''
        requirements = set(['init.sls', 'pillar.sls'])
        files = os.listdir(self.path)
        missing_files = list(requirements.difference(files))
        if missing_files:
            raise Exception('Missing files: {}'.format(missing_files))

    def install(self):
        '''
        Install state layer (link, add to includes on dynamic sls files)
        '''
        self._link()
        self._add_to_dynamics()

    def _link(self):
        '''
        Install state layer into dynamic salt roots (state/pillar).
        '''
        linked_state_path = os.path.join(STATE_ROOT, self.name)
        pillar_path = os.path.join(self.layer_path, 'pillar.sls')
        linked_pillar_filename = '{}.sls'.format(self.name)
        linked_pillar_path = os.path.join(PILLAR_ROOT, linked_pillar_filename)

        links = [
            # layer path
            (self.path, self.layer_path),
            # linked state
            (self.layer_path, linked_state_path),
            # linked pillar
            (pillar_path, linked_pillar_path),
        ]

        for src, dst in links:
            if os.path.exists(dst):
                if os.path.samefile(src, dst):
                    _LOG.debug('Already symlinked: %s -> %s', src, dst)
                    continue
                dst_linked_to = os.path.realpath(dst)
                raise Exception('Destination {} points to {} (expected {})'.format(dst, dst_linked_to, src))
            _LOG.debug("Creating symlink: %s -> %s", src, dst)
            os.symlink(src, dst)

    def _add_to_dynamics(self):
        for root in (PILLAR_ROOT, STATE_ROOT):
            sls_file = os.path.join(root, 'dynamic.sls')
            self._add_to_sls_include(sls_file)

    def _add_to_sls_include(self, sls_file):
        '''
        Given an sls file path, it will put our name within an include block.

        If the file doesn't exist it will be created.
        If the file doesn't contain an include block one will be added.
        '''
        # Create file if it does not exist.
        if not os.path.exists(sls_file):
            _LOG.debug('Creating file: %s', sls_file)
            touch(sls_file)

        with open(sls_file, 'r+') as fp:
            contents = yaml.load(fp)

            if not contents:
                contents = dict(include=[])
            elif 'include' not in contents:
                contents['include'] = []

            if self.name in contents['include']:
                _LOG.debug('Already included %s in sls %s', self.name, sls_file)
                return

            _LOG.debug('Adding %s as include in sls %s', self.name, sls_file)
            contents['include'].append(self.name)

            # Write new file using existing file handle
            fp.seek(0)
            yaml.dump(contents, fp)
            fp.truncate()

    def apply(self, display_output=True, force_color=True):
        '''
        Applies the State Layer.
        '''
        _LOG.info("Applying state layer: %s", self.name)

        # Create salt client instance
        caller = salt.client.Caller()
        # Set any minion options
        if force_color:
            caller.opts['force_color'] = True

        # Run minion function to apply state
        ret = caller.cmd('state.sls', self.name)
        _LOG.debug('Salt layer %s apply ret: %s', self.name, ret)

        if display_output:
            # Use salt outputter to display nicely
            salt.output.display_output({'local': ret}, 'highstate', caller.opts)

        # I hate this, but this is how it's done in salt.cli.caller
        func = caller.sminion.functions['state.sls']
        retcode = sys.modules[func.__module__].__context__.get('retcode', 0)

        return retcode


def main():
    '''
    Main
    '''
    if len(sys.argv) != 2:
        basename = os.path.basename(sys.argv[0])
        print("Usage: %s LAYER_PATH" % basename, file=sys.stderr)
        sys.exit(1)
    path = sys.argv[1]
    layer = StateLayer(path)
    layer.install()
    try:
        retcode = layer.apply()
    finally:
        image_cleanup()
    sys.exit(retcode)


if __name__ == '__main__':
    main()
